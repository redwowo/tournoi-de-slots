<!DOCTYPE html>
<html lang="fr" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tournoi 16 joueurs - Suivi des éliminations</title>
    <link rel="icon" type="image/png" href="fly.png">
    <style>
        :root {
            --bg-color: #f8f9fa;
            --text-color: #333;
            --card-bg: #fff;
            --border-color: #e2e8f0;
            --item-bg: #f8f9fa;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --btn-bg: #333;
            --btn-text: white;
            --btn-hover: #000;
            --btn-disabled: #888;
            --eliminated-color: red;
            --victory-bg: gold;
            --overlay-bg: rgba(0, 0, 0, 0.8);
            --heading-color: #1e293b;
            --muted-text: #666;
            --success-color: #10b981;
            --success-bg: #d1fae5;
            --success-text: #065f46;
            --toast-bg: rgba(255, 255, 255, 0.95);
            --toast-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            --toast-error-bg: #fee2e2;
            --toast-error-border: #ef4444;
            --toast-success-bg: #dcfce7;
            --toast-success-border: #10b981;
            --warning-color: #f59e0b;
            --warning-bg: #fef3c7;
            --warning-text: #92400e;
            --category-bg: #3b82f6;
            --category-text: white;
            --nolimit-category-bg: #ef4444;
            --hacksaw-category-bg: #3b82f6;
            
            /* Nouvelles variables pour le dialogue de sélection aléatoire */
            --primary-color: #3b82f6;
            --primary_hover: #2563eb;
            --card-radius: 0.75rem;
            --card-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            --animation-duration: 0.3s;
            --slot-result-bg: rgba(59, 130, 246, 0.1);
            --slot-result-border: rgba(59, 130, 246, 0.3);
            --radio-size: 1.25rem;
            --radio-checked-bg: #3b82f6;
            --radio-border: #d1d5db;
        }

        .dark {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --card-bg: #2a2a2a;
            --border-color: #444;
            --item-bg: #333;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --btn-bg: #555;
            --btn-text: #e0e0e0;
            --btn-hover: #777;
            --btn-disabled: #444;
            --eliminated-color: #ff6b6b;
            --victory-bg: #ffd700;
            --overlay-bg: rgba(0, 0, 0, 0.9);
            --heading-color: #e0e0e0;
            --muted-text: #aaa;
            --success-color: #34d399;
            --success-bg: rgba(16, 185, 129, 0.2);
            --success-text: #d1fae5;
            --toast-bg: rgba(26, 26, 26, 0.95);
            --toast-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            --toast-error-bg: rgba(239, 68, 68, 0.2);
            --toast-error-border: #ef4444;
            --toast-success-bg: rgba(16, 185, 129, 0.2);
            --toast-success-border: #10b981;
            --warning-color: #fbbf24;
            --warning-bg: rgba(245, 158, 11, 0.2);
            --warning-text: #fef3c7;
            --nolimit-category-bg: #ef4444;
            --hacksaw-category-bg: #3b82f6;
            
            /* Nouvelles variables pour le dialogue de sélection aléatoire en mode sombre */
            --slot-result-bg: rgba(59, 130, 246, 0.15);
            --slot-result-border: rgba(59, 130, 246, 0.4);
            --radio-border: #555;
        }

        body { 
            font-family: Arial, sans-serif; 
            background-color: var(--bg-color); 
            color: var(--text-color);
            margin: 0;
            padding: 1rem;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
            min-height: 100vh;
            box-sizing: border-box;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .main-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 2rem;
            margin-top: 1.5rem;
            max-width: 1400px; /* Increased from 1200px */
            margin-left: auto;
            margin-right: auto;
            padding: 0 1rem;
        }

        /* Sidebar à gauche */
        .sidebar { 
            width: 300px; 
            background: var(--card-bg); 
            color: var(--text-color);
            padding: 1rem; 
            border-radius: 0.5rem; 
            box-shadow: 0 2px 10px var(--shadow-color);
            text-align: center;
            position: sticky;
            top: 1rem;
            transition: background-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease;
        }

        .sidebar h3 { 
            margin-bottom: 0.75rem; 
            text-align: center; 
            color: var(--text-color);
        }

        .sidebar ul { 
            list-style: none; 
            padding: 0; 
            text-align: left;
            margin-bottom: 1rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .sidebar li { 
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            background-color: var(--item-bg);
            transition: background-color 0.3s ease;
        }

        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .remove-btn {
            background: none;
            border: none;
            color: #ef4444;
            cursor: pointer;
            font-size: 1rem;
            padding: 0.25rem;
            margin-left: 0.5rem;
            transition: transform 0.2s;
        }

       @keyframes smoothPulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.15); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        .remove-btn:hover {
            animation: smoothPulse 0.4s ease-in-out;
            color: #dc2626; /* Rouge un peu plus foncé */
        }

	.remove-btn img {
    	    width: 16px;
    	    height: 16px;
    	    vertical-align: middle;
	}

        /* Bracket à droite */
        .bracket { 
            display: flex;  
            gap: 2rem; /* Reduced from 2.5rem to save space */
            overflow-x: auto;
            padding-bottom: 1rem;
            width: 100%;
            position: relative;
        }

        .round { 
            display: flex; 
            flex-direction: column;
            position: relative;
            min-width: 180px; /* Reduced from 220px */
            z-index: 1;
        }

        .round h3 {
            text-align: center;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: var(--text-color);
        }

        .match-wrapper {
            position: relative;
            margin-bottom: 2rem;
        }

        .match { 
            border: 1px solid var(--border-color); 
            padding: 0.5rem; /* Reduced from 0.75rem */
            display: flex; 
            flex-direction: column; 
            gap: 0.25rem; /* Reduced from 0.5rem */
            border-radius: 0.5rem; 
            background: var(--card-bg); 
            box-shadow: 0 2px 8px var(--shadow-color);
            position: relative;
            z-index: 2;
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
            min-width: 150px; /* Added to ensure minimum width */
            max-width: 220px; /* Added to limit maximum width */
        }

        .player-btn { 
            padding: 0.4rem; /* Reduced from 0.5rem */
            cursor: pointer; 
            background: var(--btn-bg); 
            color: var(--btn-text); 
            border: none; 
            border-radius: 0.25rem; 
            font-weight: 500;
            width: 100%;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            font-size: 0.9rem; /* Added to make text slightly smaller */
        }

        .player-btn:hover { 
            background: var(--btn-hover); 
        }

        .player-btn:disabled {
            background: var(--btn-disabled);
            cursor: not-allowed;
        }

        .player-btn.winner {
            background: var(--success-bg);
            color: var(--success-text);
            border: 1px solid var(--success-color);
        }

        .player-btn.waiting {
            background: var(--btn-disabled);
            cursor: not-allowed;
        }

        .player-btn.waiting::after {
            content: "En attente d'adversaire";
            position: absolute;
            bottom: -25px;
            left: 0;
            right: 0;
            font-size: 0.7rem;
            color: var(--muted-text);
            font-style: italic;
        }

        .eliminated { 
            text-decoration: line-through; 
            color: var(--eliminated-color); 
            transition: all 0.3s ease;
        }

        .checkmark {
            display: inline-block;
            margin-left: 5px;
            color: var(--success-color);
        }

        input { 
            padding: 0.75rem; 
            width: 100%;
            margin-bottom: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            box-sizing: border-box;
            font-size: 0.9rem;
            background-color: var(--card-bg);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }

        button { 
            padding: 0.75rem;
            background: var(--btn-bg);
            color: var(--btn-text);
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
            font-size: 0.9rem;
        }

        button:hover {
            background: var(--btn-hover);
        }

        button:disabled {
            background: var(--btn-disabled);
            cursor: not-allowed;
        }

        .btn-outline {
            background: var(--card-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }

        .btn-outline:hover {
            background: var(--item-bg);
        }

        .btn-add {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            width: 100%;
            margin-bottom: 1rem;
        }

        #victoryMessage {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            padding: 1.5rem;
            background: var(--victory-bg);
            color: #000; /* Always keep text dark on gold background */
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px var(--shadow-color);
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -60%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9998;
            display: none;
            background: var(--overlay-bg);
        }

        h1 {
            text-align: center;
            font-size: 2rem;
            font-weight: bold;
            margin-top: 1.25rem;
            color: var(--heading-color);
            transition: color 0.3s ease;
        }

        .trophy-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            display: block;
        }

        .add-icon, .shuffle-icon {
            margin-right: 0.25rem;
            font-size: 1.1rem;
        }

        .input-container {
            margin-bottom: 0.5rem;
        }

        .divider {
            height: 1px;
            background-color: var(--border-color);
            margin: 1rem 0;
            width: 100%;
            transition: background-color 0.3s ease;
        }

        .match-info {
            font-size: 0.8rem;
            color: var(--muted-text);
            text-align: center;
            margin-top: 0.5rem;
            font-style: italic;
            transition: color 0.3s ease;
        }

        /* Theme toggle button */
        .theme-toggle {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: var(--btn-bg);
            color: var(--btn-text);
            border: none;
            border-radius: 50%;
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 2px 5px var(--shadow-color);
            transition: background-color 0.3s ease;
        }

        .theme-toggle:hover {
            background: var(--btn-hover);
        }

	.theme-toggle img {
    	    width: 20px;
    	    height: 20px;
	}

        /* Toast notifications */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 350px;
        }

        .toast {
            padding: 12px 16px;
            border-radius: 6px;
            background: var(--toast-bg);
            box-shadow: var(--toast-shadow);
            display: flex;
            flex-direction: column;
            animation: slideIn 0.3s ease-out;
            transition: transform 0.3s ease, opacity 0.3s ease;
            border-left: 4px solid transparent;
        }

        .toast.error {
            background: var(--toast-error-bg);
            border-left-color: var(--toast-error-border);
        }

        .toast.success {
            background: var(--toast-success-bg);
            border-left-color: var(--toast-success-border);
        }

        .toast.warning {
            background: var(--warning-bg);
            border-left-color: var(--warning-color);
        }

        .toast-title {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .toast-message {
            font-size: 0.9rem;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        /* Elimination history modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999;
        }

        .modal-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            background: var(--overlay-bg);
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px var(--shadow-color);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            margin-bottom: 1rem;
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .modal-description {
            color: var(--muted-text);
            font-size: 0.9rem;
        }

        .modal-body {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 1rem;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
        }

        .elimination-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .elimination-item {
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            margin-bottom: 0.75rem;
        }

        .elimination-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .eliminated-player {
            font-weight: bold;
            color: var(--eliminated-color);
        }

        .elimination-round {
            font-size: 0.8rem;
            padding: 0.25rem 0.5rem;
            background: var(--item-bg);
            border-radius: 0.25rem;
        }

        .elimination-details {
            font-size: 0.9rem;
            color: var(--muted-text);
        }

        .elimination-time {
            font-size: 0.8rem;
            color: var(--muted-text);
            margin-top: 0.5rem;
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            font-weight: 500;
            border-radius: 9999px;
            background: var(--item-bg);
            position: absolute;
            top: -8px;
            right: -8px;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
                align-items: center;
                gap: 1.5rem;
            }

            .sidebar {
                width: 100%;
                position: static;
                max-width: 100%;
            }

            .bracket {
                flex-direction: column;
                align-items: center;
                gap: 2rem;
            }

            .round {
                width: 100%;
                align-items: center;
            }

            .match-wrapper {
                width: 100%;
                max-width: 300px;
            }

            .connector {
                display: none;
            }

            h1 {
                font-size: 1.5rem;
            }
            
            .player-btn.waiting::after {
                position: static;
                display: block;
                margin-top: 0.25rem;
            }

            .theme-toggle {
                top: 0.5rem;
                right: 0.5rem;
            }

            .modal-content {
                width: 95%;
                max-height: 90vh;
            }
        }

        .input-error {
            border: 2px solid #ef4444;
            animation: shake 0.5s;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        /* Confirmation dialog */
        .confirm-dialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px var(--shadow-color);
            z-index: 9999;
            max-width: 400px;
            width: 90%;
        }

        .confirm-dialog-title {
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .confirm-dialog-message {
            margin-bottom: 1.5rem;
            color: var(--text-color);
        }

        .confirm-dialog-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }

        .btn-danger {
            background-color: #ef4444;
        }

        .btn-danger:hover {
            background-color: #dc2626;
        }

        /* Reset dialog */
        .reset-dialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px var(--shadow-color);
            z-index: 9999;
            max-width: 400px;
            width: 90%;
        }

        .reset-dialog-title {
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .reset-dialog-message {
            margin-bottom: 1.5rem;
            color: var(--text-color);
        }

        .reset-dialog-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .shuffle-icon {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .dice-icon {
            width: 18px; /* Ajustable selon la taille souhaitée */
            height: 18px;
	    position: relative;
	    top: 4px;
        }

	#launchDraw {
    	    padding-top: 12px;  /* Augmente ou diminue pour équilibrer */
    	    padding-bottom: 12px;
	    line-height: 1.6;
	}

/* Panneau des résultats précédents */
.previous-winners-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    width: 100%;
    margin-top: 1rem;
    background-color: var(--card-bg);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    padding: 0.75rem;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.previous-winners-btn:hover {
    background-color: var(--item-bg);
}

.previous-winners-btn .trophy-icon {
    color: gold;
    font-size: 1.25rem;
    margin: 0;
    display: inline;
}

/* Modal des gagnants précédents */
.winners-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 9999;
}

.winners-modal-overlay {
    position: absolute;
    width: 100%;
    height: 100%;
    background: var(--overlay-bg);
}

.winners-modal-content {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--card-bg);
    padding: 2rem;
    border-radius: 0.75rem;
    box-shadow: 0 8px 24px var(--shadow-color);
    max-width: 700px;
    width: 90%;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
}

.winners-modal-header {
    display: flex;
    align-items: center;
    margin-bottom: 1.5rem;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 1rem;
}

.winners-modal-title {
    font-size: 1.5rem;
    font-weight: bold;
    margin-bottom: 0.5rem;
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.winners-modal-title .trophy-icon {
    color: gold;
    font-size: 1.75rem;
    margin: 0;
    display: inline;
}

.winners-modal-description {
    color: var(--muted-text);
    font-size: 1rem;
    margin-top: 0.5rem;
}

.winners-modal-body {
    flex: 1;
    overflow-y: auto;
    margin-bottom: 1.5rem;
}

.winners-modal-footer {
    display: flex;
    justify-content: flex-end;
    border-top: 1px solid var(--border-color);
    padding-top: 1rem;
}

.winners-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 1rem;
}

.winner-item {
    display: flex;
    align-items: center;
    padding: 1rem;
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    background-color: var(--item-bg);
    transition: background-color 0.3s ease, transform 0.2s ease;
}

.winner-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px var(--shadow-color);
}

.winner-trophy {
    margin-right: 0.75rem;
    color: gold;
    font-size: 1.5rem;
}

.winner-info {
    flex: 1;
    text-align: left;
}

.winner-name {
    font-weight: bold;
    margin-bottom: 0.25rem;
    font-size: 1.1rem;
}

.winner-date {
    font-size: 0.85rem;
    color: var(--muted-text);
}

.no-winners {
    padding: 2rem;
    color: var(--muted-text);
    font-style: italic;
    text-align: center;
    font-size: 1.1rem;
    background-color: var(--item-bg);
    border-radius: 0.5rem;
    border: 1px dashed var(--border-color);
}

/* Bouton d'annulation de match */
.undo-match-btn {
    background-color: var(--warning-color);
    color: white;
    border: none;
    border-radius: 0.25rem;
    padding: 0.4rem 0.6rem;
    font-size: 0.8rem;
    cursor: pointer;
    margin-top: 0.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.25rem;
    transition: background-color 0.2s ease;
}

.undo-match-btn:hover {
    background-color: #e69009;
}

.undo-match-btn:disabled {
    background-color: #d1d5db;
    cursor: not-allowed;
}

.undo-icon {
    width: 14px;
    height: 14px;
    display: inline-block;
}

/* Confirmation d'annulation */
.undo-confirm-dialog {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--card-bg);
    padding: 1.5rem;
    border-radius: 0.5rem;
    box-shadow: 0 4px 12px var(--shadow-color);
    z-index: 9999;
    max-width: 450px;
    width: 90%;
}

.undo-confirm-title {
    font-size: 1.25rem;
    font-weight: bold;
    margin-bottom: 0.5rem;
    color: var(--warning-color);
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.undo-confirm-message {
    margin-bottom: 1.5rem;
    color: var(--text-color);
    line-height: 1.5;
}

.undo-confirm-buttons {
    display: flex;
    justify-content: flex-end;
    gap: 0.75rem;
}

.btn-warning {
    background-color: var(--warning-color);
}

.btn-warning:hover {
    background-color: #e69009;
}

.score-inputs {
    display: flex;
    gap: 0.25rem;
    margin-top: 0.25rem;
    margin-bottom: 0.25rem;
    justify-content: center;
}

.score-inputs input {
    padding: 0.35rem;
    width: 45px;
    font-size: 1rem;
    text-align: center;
    margin-bottom: 0;
}

.score-separator {
    display: flex;
    align-items: center;
    color: var(--muted-text);
}

.score-display {
    font-size: 1.1rem;
    color: var(--muted-text);
    text-align: center;
    margin-top: 0.5rem;
}

.score-note {
    font-size: 0.75rem;
    color: var(--muted-text);
    text-align: center;
    margin-top: 0.25rem;
    margin-bottom: 0.25rem;
    font-style: italic;
}

.score-box {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 0.25rem;
    margin-bottom: 0.25rem;
    background-color: var(--item-bg);
    border-radius: 0.25rem;
    padding: 0.25rem 0.75rem;
    border: 1px solid var(--border-color);
}

.score-box-label {
    font-size: 0.8rem;
    color: var(--muted-text);
    margin-bottom: 0.25rem;
}

.score-box-value {
    display: flex;
    gap: 0.5rem;
    font-size: 1.1rem;
    font-weight: bold;
}

/* Styles pour la catégorie */
.category-badge {
    display: inline-block;
    padding: 0.2rem 0.5rem;
    font-size: 0.7rem;
    font-weight: 500;
    border-radius: 9999px;
    color: var(--category-text);
    margin-left: 0.5rem;
}

.category-badge.hacksaw {
    background-color: var(--hacksaw-category-bg);
}

.category-badge.nolimit {
    background-color: var(--nolimit-category-bg);
}

/* Styles améliorés pour le modal de sélection aléatoire */
.random-slot-dialog {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--card-bg);
    padding: 0;
    border-radius: var(--card-radius);
    box-shadow: var(--card-shadow);
    z-index: 9999;
    max-width: 500px;
    width: 90%;
    overflow: hidden;
}

.random-slot-header {
    padding: 1.25rem 1.5rem;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.random-slot-title {
    font-size: 1.25rem;
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    color: var(--heading-color);
}

.random-slot-title-icon {
    width: 24px;
    height: 24px;
    color: var(--primary-color);
}

.random-slot-close {
    background: none;
    border: none;
    color: var(--muted-text);
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s ease;
}

.random-slot-close:hover {
    background-color: var(--item-bg);
}

.random-slot-content {
    padding: 1.5rem;
}

.random-slot-description {
    margin-bottom: 1.5rem;
    color: var(--muted-text);
    line-height: 1.5;
}

.slot-type-selection {
    margin: 1.5rem 0;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.slot-type-option {
    display: flex;
    align-items: center;
    padding: 0.75rem;
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    cursor: pointer;
    transition: all var(--animation-duration) ease;
}

.slot-type-option:hover {
    background-color: var(--item-bg);
}

.slot-type-option.selected {
    border-color: var(--primary-color);
    background-color: rgba(59, 130, 246, 0.05);
}

.slot-type-radio {
    position: relative;
    width: var(--radio-size);
    height: var(--radio-size);
    border: 2px solid var(--radio-border);
    border-radius: 50%;
    margin-right: 0.75rem;
    display: flex;
    align-items: center;
    justify-content: center;
}

.slot-type-option.selected .slot-type-radio {
    border-color: var(--primary-color);
}

.slot-type-radio::after {
    content: '';
    position: absolute;
    width: calc(var(--radio-size) - 10px);
    height: calc(var(--radio-size) - 10px);
    border-radius: 50%;
    background-color: var(--primary-color);
    opacity: 0;
    transform: scale(0);
    transition: all var(--animation-duration) ease;
}

.slot-type-option.selected .slot-type-radio::after {
    opacity: 1;
    transform: scale(1);
}

.slot-type-label {
    display: flex;
    flex-direction: column;
    flex: 1;
}

.slot-type-name {
    font-weight: 500;
    margin-bottom: 0.25rem;
}

.slot-type-badge {
    display: inline-flex;
    align-items: center;
    padding: 0.25rem 0.5rem;
    border-radius: 9999px;
    font-size: 0.75rem;
    font-weight: 500;
    margin-left: 0.5rem;
}

.slot-type-badge.hacksaw {
    background-color: var(--hacksaw-category-bg);
    color: white;
}

.slot-type-badge.nolimit {
    background-color: var(--nolimit-category-bg);
    color: white;
}

.random-slot-result {
    margin: 1.5rem 0;
    padding: 1.5rem;
    background-color: var(--slot-result-bg);
    border: 1px solid var(--slot-result-border);
    border-radius: 0.75rem;
    text-align: center;
    display: none;
    animation: fadeInScale var(--animation-duration) ease;
}

@keyframes fadeInScale {
    from { opacity: 0; transform: scale(0.95); }
    to { opacity: 1; transform: scale(1); }
}

@keyframes slotMachine {
    0% { transform: translateY(-20px); opacity: 0; }
    10% { transform: translateY(0); opacity: 1; }
    90% { transform: translateY(0); opacity: 1; }
    100% { transform: translateY(20px); opacity: 0; }
}

.random-slot-icon {
    width: 48px;
    height: 48px;
    margin: 0 auto 1rem;
    color: var(--primary-color);
}

.random-slot-name {
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--heading-color);
    margin-bottom: 0.5rem;
}

.random-slot-category {
    display: inline-flex;
    padding: 0.25rem 0.75rem;
    border-radius: 9999px;
    font-size: 0.85rem;
    font-weight: 500;
    margin-top: 0.5rem;
}

.random-slot-category.hacksaw {
    background-color: var(--hacksaw-category-bg);
    color: white;
}

.random-slot-category.nolimit {
    background-color: var(--nolimit-category-bg);
    color: white;
}

.random-slot-footer {
    padding: 1.25rem 1.5rem;
    border-top: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.btn-primary {
    background-color: var(--primary-color);
    color: white;
    border: none;
    padding: 0.75rem 1rem;
    border-radius: 0.5rem;
    font-weight: 500;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    transition: background-color var(--animation-duration) ease;
}

.btn-primary:hover {
    background-color: var(--primary_hover);
}

.btn-primary:disabled {
    opacity: 0.7;
    cursor: not-allowed;
}

.btn-primary .spinner {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.btn-add-slot {
    background-color: var(--success-color);
    display: none;
}

.btn-add-slot:hover {
    background-color: #0d9488;
}

.slot-selecting {
    position: relative;
    height: 2rem;
    overflow: hidden;
    margin: 1rem 0;
}

.slot-item {
    position: absolute;
    width: 100%;
    text-align: center;
    font-weight: bold;
    font-size: 1.25rem;
    animation: slotMachine 0.2s ease-in-out;
    opacity: 0;
}

/* Ajouter ce bloc CSS dans la section des styles pour supprimer les flèches des champs numériques */
/* Masquer les flèches pour Chrome, Safari, Edge et Opera */
input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

/* Masquer les flèches pour Firefox */
input[type=number] {
    -moz-appearance: textfield;
    appearance: textfield;
}

/* Ajouter ce style CSS dans la section des styles */
.suggestions-container {
    position: absolute;
    width: 100%;
    max-height: 200px;
    overflow-y: auto;
    background-color: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    box-shadow: 0 4px 12px var(--shadow-color);
    z-index: 100;
    margin-top: 2px;
    display: none;
}

.suggestion-item {
    padding: 0.75rem;
    cursor: pointer;
    transition: background-color 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.suggestion-item:hover {
    background-color: var(--item-bg);
}

.suggestion-name {
    font-weight: 500;
}

.suggestion-category {
    font-size: 0.8rem;
    padding: 0.2rem 0.5rem;
    border-radius: 9999px;
    color: white;
    margin-left: 0.5rem;
}

.suggestion-category.hacksaw {
    background-color: var(--hacksaw-category-bg);
}

.suggestion-category.nolimit {
    background-color: var(--nolimit-category-bg);
}

.no-suggestions {
    padding: 0.75rem;
    color: var(--muted-text);
    font-style: italic;
    text-align: center;
}

/* Style pour la mention légale */
.legal-notice {
    position: fixed;
    bottom: 15px;
    left: 15px;
    background-color: var(--card-bg);
    color: var(--muted-text);
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 0.75rem;
    box-shadow: 0 2px 5px var(--shadow-color);
    z-index: 50;
    border: 1px solid var(--border-color);
    max-width: 200px;
    text-align: center;
    line-height: 1.4;
    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
}
    </style>
</head>
<body>
    <!-- Theme toggle button -->
    <button class="theme-toggle" id="themeToggle" aria-label="Changer de thème">🌓</button>

    <!-- Titre -->
    <h1>
        <img src="./sept.png" alt="Slot Machine" width="32" height="32">
        Tournoi de Slots
        <img src="./sept.png" alt="Slot Machine" width="32" height="32">
    </h1>

    <!-- Conteneur principal -->
    <div class="main-container">

        <!-- Sidebar gauche -->
        <div class="sidebar">
            <h3>👥 Participants :</h3>
            <ul id="playersDisplay"></ul>
            
            <div class="divider"></div>
            
            <div id="addPlayerContainer" class="input-container">
                <input type="text" id="playerName" placeholder="✍️ Nom de la machine">
		<div class="suggestions-container" id="suggestionsList"></div>
                <button id="addPlayerBtn" onclick="addPlayer()" class="btn-add">
                    <span class="add-icon">
    			<img src="./slot.png" 
         		alt="Slot Machine" width="20" height="20">
		    </span> 
		    Ajouter la Slot
                </button>
            </div>
            
            <p id="count">Slot ajoutés : 0/16</p>
            
            <button id="randomSlotBtn" onclick="showRandomSlotDialog()" class="btn-outline" style="width: 100%; margin-bottom: 1rem;">
                <span class="shuffle-icon">
    		<img src="./de.png" 
         	alt="Dé" class="dice-icon">
		</span> 
		Choisir une slot aléatoire
            </button>
            
            <button id="launchDraw" onclick="launchDraw()" style="display: none; width: 100%;">
                <span class="shuffle-icon">
    		<img src="./de.png" 
         	alt="Dé" class="dice-icon">
		</span> 
		Lancer le tirage
            </button>
            
            <button id="resetButton" onclick="showResetConfirmDialog()" class="btn-outline" style="display: none; width: 100%; margin-top: 1rem;">
                Réinitialiser le tournoi
            </button>
            
            <!-- Bouton d'historique des éliminations -->
            <button id="eliminationHistoryBtn" onclick="showEliminationHistory()" class="btn-outline" style="display: none; width: 100%; margin-top: 1rem;">
                <span style="margin-right: 0.5rem;">📋</span> Historique des éliminations
            </button>
            
            <!-- Bouton pour effacer toutes les données -->
            <button id="clearDataBtn" onclick="showConfirmDialog('Effacer toutes les données', 'Êtes-vous sûr de vouloir effacer toutes les données ? Cette action est irréversible.', clearAllData)" class="btn-outline" style="width: 100%; margin-top: 1rem;">
                <img src="./poubelle.png" alt="Poubelle" width="16" height="16" style="margin-right: 0.5rem;"> Effacer toutes les données
            </button>
            
            <!-- Bouton pour afficher les résultats des tournois précédents -->
            <button id="showPreviousWinnersBtn" onclick="toggleWinnersPanel()" class="previous-winners-btn">
                <span class="trophy-icon">🏆</span> Résultats tournois précédents
            </button>
        </div>

        <!-- Tableau de tournoi à droite -->
        <div class="bracket" id="bracket" style="display: none;"></div>
    </div>

    <!-- Overlay et message de victoire -->
    <div id="overlay"></div>
    <div id="victoryMessage">
        <span class="trophy-icon">🏆</span>
        <p id="winnerText"></p>
        <button onclick="closeVictoryMessage()" style="margin-top: 1rem;">Fermer</button>
    </div>
    
    <!-- Toast container -->
    <div class="toast-container" id="toastContainer"></div>
    
    <!-- Confirmation dialog -->
    <div class="confirm-dialog" id="confirmDialog">
        <div class="confirm-dialog-title" id="confirmDialogTitle"></div>
        <div class="confirm-dialog-message" id="confirmDialogMessage"></div>
        <div class="confirm-dialog-buttons">
            <button class="btn-outline" onclick="closeConfirmDialog()">Annuler</button>
            <button class="btn-danger" id="confirmDialogConfirmBtn">Confirmer</button>
        </div>
    </div>
    
    <!-- Reset dialog -->
    <div class="reset-dialog" id="resetDialog">
        <div class="reset-dialog-title">Réinitialiser le tournoi</div>
        <div class="reset-dialog-message">Comment souhaitez-vous réinitialiser le tournoi ?</div>
        <div class="reset-dialog-buttons">
            <button onclick="resetTournamentWithOption(true)">Conserver la liste des joueurs</button>
            <button class="btn-danger" onclick="resetTournamentWithOption(false)">Tout réinitialiser</button>
            <button class="btn-outline" onclick="closeResetDialog()">Annuler</button>
        </div>
    </div>
    
    <!-- Modal d'historique des éliminations -->
    <div class="modal" id="eliminationHistoryModal">
        <div class="modal-overlay" onclick="closeEliminationHistory()"></div>
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Historique des éliminations</div>
                <div class="modal-description">Liste chronologique des joueurs éliminés durant le tournoi</div>
            </div>
            <div class="modal-body">
                <ul class="elimination-list" id="eliminationList"></ul>
            </div>
            <div class="modal-footer">
                <button onclick="closeEliminationHistory()">Fermer</button>
            </div>
        </div>
    </div>
    
    <!-- Modal des gagnants précédents -->
    <div class="winners-modal" id="winnersPanel">
        <div class="winners-modal-overlay" onclick="toggleWinnersPanel()"></div>
        <div class="winners-modal-content">
            <div class="winners-modal-header">
                <div>
                    <div class="winners-modal-title">
                        <span class="trophy-icon">🏆</span> Anciens Gagnants
                    </div>
                    <div class="winners-modal-description">Palmarès des vainqueurs des tournois précédents</div>
                </div>
            </div>
            <div class="winners-modal-body">
                <ul class="winners-list" id="winnersList">
                    <li class="no-winners">Aucun gagnant enregistré</li>
                </ul>
            </div>
            <div class="winners-modal-footer">
                <button onclick="toggleWinnersPanel()">Fermer</button>
            </div>
        </div>
    </div>
    
    <!-- Confirmation d'annulation de match -->
    <div class="undo-confirm-dialog" id="undoConfirmDialog">
        <div class="undo-confirm-title">
            <span>⚠️</span> Annuler le résultat du match
        </div>
        <div class="undo-confirm-message" id="undoConfirmMessage">
            Êtes-vous sûr de vouloir annuler le résultat de ce match ? Cette action peut avoir des conséquences sur les tours suivants.
        </div>
        <div class="undo-confirm-buttons">
            <button class="btn-outline" onclick="closeUndoConfirmDialog()">Annuler</button>
            <button class="btn-warning" id="undoConfirmBtn">Confirmer l'annulation</button>
        </div>
    </div>
    
    <!-- Modal amélioré de sélection aléatoire de slot -->
    <div class="random-slot-dialog" id="randomSlotDialog">
        <div class="random-slot-header">
            <div class="random-slot-title">
                <img src="./de.png" alt="Dé" class="random-slot-title-icon">
                Sélection aléatoire de machine
            </div>
            <button class="random-slot-close" onclick="closeRandomSlotDialog()">
                <img src="./croix.png" alt="Fermer" width="16" height="16">
            </button>
        </div>
        
        <div class="random-slot-content">
            <div class="random-slot-description">
                Sélectionnez le type de machine à sous que vous souhaitez choisir aléatoirement.
            </div>
            
            <div class="slot-type-selection" id="slotTypeSelection">
                <div class="slot-type-option selected" data-value="all" onclick="selectSlotType(this, 'all')">
                    <div class="slot-type-radio"></div>
                    <div class="slot-type-label">
                        <span class="slot-type-name">Toutes les machines</span>
                    </div>
                </div>
                
                <div class="slot-type-option" data-value="hacksaw" onclick="selectSlotType(this, 'hacksaw')">
                    <div class="slot-type-radio"></div>
                    <div class="slot-type-label">
                        <span class="slot-type-name">Uniquement Hacksaw Gaming</span>
                        <span class="slot-type-badge hacksaw">Hacksaw</span>
                    </div>
                </div>
                
                <div class="slot-type-option" data-value="nolimit" onclick="selectSlotType(this, 'nolimit')">
                    <div class="slot-type-radio"></div>
                    <div class="slot-type-label">
                        <span class="slot-type-name">Uniquement Nolimit City</span>
                        <span class="slot-type-badge nolimit">Nolimit</span>
                    </div>
                </div>
            </div>
            
            <div class="slot-selecting" id="slotSelecting" style="display: none;">
                <!-- Les éléments seront ajoutés dynamiquement pendant l'animation -->
            </div>
            
            <div class="random-slot-result" id="randomSlotResult">
                <img src="./slot.png" alt="Slot Machine" class="random-slot-icon">
                <div class="random-slot-name" id="randomSlotName"></div>
                <div class="random-slot-category" id="randomSlotCategory"></div>
            </div>
        </div>
        
        <div class="random-slot-footer">
            <button class="btn-outline" onclick="closeRandomSlotDialog()">Annuler</button>
            <div>
                <button class="btn-primary" id="selectRandomBtn" onclick="selectRandomSlot()">
                    <img src="./de.png" alt="Dé" width="16" height="16">
                    Sélectionner aléatoirement
                </button>
                <button class="btn-primary btn-add-slot" id="addRandomSlotBtn" onclick="addRandomSlot()">
                    <img src="./slot.png" alt="Slot Machine" width="16" height="16">
                    Ajouter cette machine
                </button>
            </div>
        </div>
    </div>

    <script>
        // Déclaration des variables globales avec let pour permettre leur réassignation
        let players = [];
        let matches = [];
        let eliminated = [];
        let winner = "";
        let tournamentStarted = false;
        let eliminationHistory = [];
        let previousWinners = [];
        let tournamentCompleted = false;
        let randomSlotSelected = "";
        let randomSlotCategory = "";
        let selectedSlotType = "all";
        
        // Liste des machines à sous Hacksaw Gaming
        const slotMachines = [
            "Dorks of the Deep", "Strength of Hercules", "Hounds of Hell", "FRKN Bananas", 
            "Marlin Masters", "Phoenix DuelReels", "Le Viking", "Klowns", "Fire my Laser", 
            "Donut Division", "Shaolin Master", "Snow Slingers", "Duel at Dawn", "Wings of Horus", 
            "Rise of Ymir", "Get the CHEESE", "Cloud Princess", "Le Pharaoh", "Evil Eyes", 
            "Octo Attack", "Donny Dough", "Dragon's Domain", "SixSixSix", "Tai the Toad", 
            "Twisted Lab", "Ze Zeus", "Cursed Crypt", "Slayers Inc", "Jelly Slice", "Keep'em", 
            "Divine Drop", "Orb of Destiny", "Cash Crew", "Rusty & Curly", "Bouncy Bombs", 
            "Dawn of Kings", "Fist of Destruction", "Beam Boys", "Feel the Beat", "2 Wild 2 Die", 
            "Dark Summoning", "Xmas Drop", "Immortal Desire", "Eye of the Panda", "Benny the Beer", 
            "Chaos Crew 2", "Densho", "Le Bandit", "Ronin Stackways", "Drop'em", "Vending Machine", 
            "Beast Below", "Mighty Masks", "Temple of Torment", "Mayan Stackways", 
            "Cursed Seas", "Fear the Dark", "Stormforged", "Keep 'em Cool", "Magic Piggy", 
            "Bloodthirst", "Frank's Farm", "Rip City", "Rotten", "Gronk's Gems", "Book of Time", 
            "Pug Life", "Undead Fortune", "Break Bones", "Alpha Eagle", "Forest Fortune", 
            "Time Spinners", "Fruit Duel", "Dork Unit", "Born Wild", "Outlaws Inc.", 
            "Buffalo Stack'n'Sync", "Itero", "Hand Of Anubis", "Gladiator Legends", "Warrior Ways", 
            "Double Rainbow", "The Bowery Boys", "Harvest Wilds", "King Carrot", "Joker Bombs", 
            "Tasty Treats", "Cash Quest", "Wanted Dead Or a Wild", "Rocket Reels", "Toshi Video Club", 
            "Xpander", "Hop'N'Pop", "Stack'Em", "Frutz", "Aztec Twist", "Cubes 2", "Let It Snow", 
            "Mystery Motel", "Chaos Crew", "The Respinners", "Cash Compass", "Cubes", 
            "Miami Multiplier", "OmNom", "Stick'Em"
        ];

        // Liste des machines à sous Nolimit City
        const nolimitCityMachines = [
            "Mental II", "Home of the Brave", "Dead, Dead Or Deader", "Duck Hunters",
            "Tombstone Slaughter: El Gordo's Revenge", "xWays Hoarder 2", "Outsourced: Payday",
            "Tanked", "Munchies", "Outsourced: Slash Game", "Blood & Shadow 2", "Brute Force",
            "San Quentin 2: Death Row", "Skate or Die", "Stockholm Syndrome", "Outsourced",
            "Apocalypse Super xNudge®", "Punk Rocker 2", "Beheaded", "Deadwood R.I.P",
            "Loner", "Kenneth Must Die", "Tombstone: No Mercy", "BRICK SNAKE 2000",
            "Possessed", "Fire in the Hole 2", "D-Day", "Land Of The Free",
            "Devil's Crossroad", "Jingle Balls", "Nine To Five", "Roadkill",
            "Ugliest Catch", "Space Donkey", "The Crypt", "DJ Psycho",
            "True Kult", "Bounty Hunters", "The Cage", "Gluttony",
            "Whacked!", "Disturbed", "Kiss My Chainsaw", "Blood & Shadow",
            "Benji Killed In Vegas", "Walk of Shame", "Dead Canary", "Pearl Harbor",
            "Rock Bottom", "Serial", "Little Bighorn", "The Border",
            "Road Rage", "The Rave", "Folsom Prison", "Karen Maneater",
            "Remember Gulag", "Misery Mining", "Punk Toilet", "Tombstone R.I.P",
            "True Grit Redemption", "Legion X", "Evil Goblins xBomb®", "Das xBoot",
            "Mental", "xWays Hoarder xSplit", "Infectious 5 xWays®", "El Paso Gunfight xNudge®",
            "Bushido Ways xNudge®", "Fire In The Hole", "East Coast VS West Coast", "San Quentin xWays®",
            "Tomb of Akhenaten", "Warrior Graveyard xNudge", "Monkey's Gold xPays", "Buffalo Hunter",
            "Book of Shadows", "Immortal Fruits", "Golden Genie And The Walking Wilds", "Milky Ways",
            "Bonus Bunnies", "Deadwood xNudge®", "Harlequin Carnival", "Gaelic Gold",
            "Barbarian Fury", "Punk Rocker", "Poison Eve", "Dragon Tribe",
            "Tomb of Néfertiti", "Manhattan Goes Wild"
        ];

        // Fonction pour sauvegarder les données dans localStorage
        function saveDataToLocalStorage() {
            const tournamentData = {
                players,
                matches,
                eliminated,
                winner,
                tournamentStarted,
                eliminationHistory,
                previousWinners,
                tournamentCompleted
            };
            localStorage.setItem('tournamentData', JSON.stringify(tournamentData));
        }

        // Fonction pour charger les données depuis localStorage
        function loadDataFromLocalStorage() {
            const savedData = localStorage.getItem('tournamentData');
            if (savedData) {
                try {
                    const tournamentData = JSON.parse(savedData);
                    players = tournamentData.players || [];
                    matches = tournamentData.matches || [];
                    eliminated = tournamentData.eliminated || [];
                    winner = tournamentData.winner || "";
                    tournamentStarted = tournamentData.tournamentStarted || false;
                    eliminationHistory = tournamentData.eliminationHistory || [];
                    tournamentCompleted = tournamentData.tournamentCompleted || false;
                    
                    // Convertir les dates de chaîne en objets Date
                    eliminationHistory.forEach(item => {
                        if (typeof item.time === 'string') {
                            item.time = new Date(item.time);
                        }
                    });

                    previousWinners = tournamentData.previousWinners || [];
                    
                    // Convertir les dates de chaîne en objets Date pour les gagnants précédents
                    previousWinners.forEach(item => {
                        if (typeof item.date === 'string') {
                            item.date = new Date(item.date);
                        }
                    });

                    // Mettre à jour l'affichage des gagnants précédents
                    updateWinnersDisplay();
                    
                    // Mettre à jour l'interface utilisateur
                    updatePlayersDisplay();
                    document.getElementById('count').innerText = `Slot ajoutés : ${players.length}/16`;
                    
                    // Afficher/masquer les éléments appropriés
                    if (tournamentStarted) {
                        document.getElementById('bracket').style.display = 'flex';
                        document.getElementById('resetButton').style.display = 'block';
                        document.getElementById('launchDraw').style.display = 'none';
                        document.getElementById('addPlayerContainer').style.display = 'none';
                        document.getElementById('randomSlotBtn').style.display = 'none';
                        
                        if (eliminationHistory.length > 0) {
                            document.getElementById('eliminationHistoryBtn').style.display = 'block';
                        }
                        
                        renderBracket();
                    } else {
                        if (players.length === 16) {
                            document.getElementById('addPlayerContainer').style.display = 'none';
                            document.getElementById('randomSlotBtn').style.display = 'none';
                            document.getElementById('launchDraw').style.display = 'block';
                        }
                    }
                    
                    showToast("Données chargées", "Les données du tournoi précédent ont été restaurées.", "success");
                } catch (error) {
                    console.error("Erreur lors du chargement des données:", error);
                    // En cas d'erreur, réinitialiser les données
                    clearAllData();
                }
            }
        }

        // Initialiser le thème
        function initTheme() {
            // Vérifier si un thème est enregistré dans localStorage
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                document.documentElement.className = savedTheme;
            } else {
                // Vérifier les préférences système
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    document.documentElement.className = 'dark';
                } else {
                    // Si aucune préférence n'est définie, utiliser le thème clair par défaut
                    document.documentElement.className = 'light';
                }
            }
            
            // Mettre à jour l'icône du bouton
            updateThemeToggleIcon();
        }

        // Basculer entre les thèmes
        function toggleTheme() {
            if (document.documentElement.className === 'light') {
                document.documentElement.className = 'dark';
                localStorage.setItem('theme', 'dark');
            } else {
                document.documentElement.className = 'light';
                localStorage.setItem('theme', 'light');
            }
            
            // Mettre à jour l'icône du bouton
            updateThemeToggleIcon();
        }

        // Mettre à jour l'icône du bouton de thème
	function updateThemeToggleIcon() {
    	    const themeToggle = document.getElementById('themeToggle');
    	    if (document.documentElement.className === 'dark') {
        	themeToggle.innerHTML = '<img src="./soleil.png" alt="Soleil" width="20" height="20">';
        	themeToggle.setAttribute('aria-label', 'Passer au thème clair');
    	    } else {
        	themeToggle.innerHTML = '<img src="./lune.png" alt="Lune" width="20" height="20">';
        	themeToggle.setAttribute('aria-label', 'Passer au thème sombre');
    	    }
	}

        // Initialiser le bracket
        function initBracket() {
            for (let i = 0; i < 4; i++) {
                matches[i] = [];
                for (let j = 0; j < Math.pow(2, 4 - i - 1); j++) {
                    matches[i][j] = { p1: '', p2: '', score1: '', score2: '' };
                }
            }
            renderBracket();
        }

        // Rendre le bracket
        function renderBracket() {
            const bracket = document.getElementById('bracket');
            bracket.innerHTML = '';
            const rounds = ['🎯 Huitièmes', '🏅 Quarts', '🥈 Demi-finales', '🏆 Finale'];

            for (let i = 0; i < 4; i++) {
                const round = document.createElement('div');
                round.className = 'round';
                
                const roundTitle = document.createElement('h3');
                roundTitle.textContent = rounds[i];
                round.appendChild(roundTitle);
                
                const matchCount = Math.pow(2, 4 - i - 1);
                for (let j = 0; j < matchCount; j++) {
                    const matchWrapper = document.createElement('div');
                    matchWrapper.className = 'match-wrapper';
                    matchWrapper.id = `match-wrapper-${i}-${j}`;
                    
                    const match = document.createElement('div');
                    match.className = 'match';
                    match.id = `match-${i}-${j}`;
                    match.innerHTML = renderMatchButtons(i, j);
                    
                    matchWrapper.appendChild(match);
                    
                    // Ajouter les connecteurs pour les lignes
                    if (i < 3) { // Pas de connecteur pour la finale
                        // Connecteur horizontal vers la droite
                        const horizontalConnector = document.createElement('div');
                        horizontalConnector.className = 'connector connector-horizontal';
                        horizontalConnector.style.top = '50%';
                        matchWrapper.appendChild(horizontalConnector);
                    }
                    
                    // Connecteur vertical pour les matchs qui ne sont pas le dernier de leur round
                    if (j % 2 === 0 && j < matchCount - 1) {
                        const verticalConnector = document.createElement('div');
                        verticalConnector.className = 'connector connector-vertical';
                        verticalConnector.style.top = '100%';
                        verticalConnector.style.height = '2rem';
                        matchWrapper.appendChild(verticalConnector);
                    }
                    
                    round.appendChild(matchWrapper);
                }
                bracket.appendChild(round);
            }
            
            // Ajuster les espacements pour les rounds avec moins de matchs
            adjustBracketSpacing();
        }
        
        // Ajuster les espacements pour que les lignes se connectent correctement
        function adjustBracketSpacing() {
            for (let i = 1; i < 4; i++) { // Commencer au deuxième round (quarts)
                const prevRoundMatchCount = Math.pow(2, 4 - i);
                const currentRoundMatchCount = Math.pow(2, 4 - i - 1);
                
                for (let j = 0; j < currentRoundMatchCount; j++) {
                    const matchWrapper = document.getElementById(`match-wrapper-${i}-${j}`);
                    if (matchWrapper) {
                        // Calculer la hauteur totale que devrait occuper ce match
                        const totalHeight = (prevRoundMatchCount / currentRoundMatchCount) * 4 + 'rem';
                        matchWrapper.style.height = totalHeight;
                        
                        // Centrer le match dans son wrapper
                        const match = matchWrapper.querySelector('.match');
                        if (match) {
                            match.style.position = 'absolute';
                            match.style.top = '50%';
                            match.style.transform = 'translateY(-50%)';
                            match.style.width = 'calc(100% - 1rem)';
                        }
                    }
                }
            }
        }

        // Rendre les boutons de match
        function renderMatchButtons(i, j) {
            const match = matches[i][j];
            const p1HasCheckmark = match.p1 && match.p1.includes(' ✓');
            const p2HasCheckmark = match.p2 && match.p2.includes(' ✓');
            const p1Name = match.p1 ? match.p1.replace(' ✓', '') : '';
            const p2Name = match.p2 ? match.p2.replace(' ✓', '') : '';
            
            // Vérifier si les deux joueurs sont présents
            const bothPlayersPresent = match.p1 && match.p2;
            const matchCompleted = p1HasCheckmark || p2HasCheckmark;
            
            // Classes et attributs pour le joueur 1
            let p1Classes = 'player-btn';
            let p1Disabled = 'disabled';
            if (match.p1) {
                if (p1HasCheckmark) {
                    p1Classes += ' winner';
                } else if (!bothPlayersPresent) {
                    p1Classes += ' waiting';
                } else if (!matchCompleted && !tournamentCompleted) {
                    p1Disabled = '';
                }
            }
            
            // Classes et attributs pour le joueur 2
            let p2Classes = 'player-btn';
            let p2Disabled = 'disabled';
            if (match.p2) {
                if (p2HasCheckmark) {
                    p2Classes += ' winner';
                } else if (!bothPlayersPresent) {
                    p2Classes += ' waiting';
                } else if (!matchCompleted && !tournamentCompleted) {
                    p2Disabled = '';
                }
            }
            
            // Ajouter le checkmark pour le gagnant
            const p1Display = p1HasCheckmark ? `${p1Name} <span class="checkmark">✓</span>` : match.p1;
            const p2Display = p2HasCheckmark ? `${p2Name} <span class="checkmark">✓</span>` : match.p2;
            
            const btn1 = match.p1 
                ? `<button class="${p1Classes}" ${p1Disabled} 
                    onclick="setWinner(${i}, ${j}, '${p1Name}')">${p1Display}</button>` 
                : `<button class="player-btn" disabled>---</button>`;
                
            const btn2 = match.p2 
                ? `<button class="${p2Classes}" ${p2Disabled} 
                    onclick="setWinner(${i}, ${j}, '${p2Name}')">${p2Display}</button>` 
                : `<button class="player-btn" disabled>---</button>`;
            
            let matchHtml = `${btn1}${btn2}`;
            
            // Ajouter un message d'information si un seul joueur est présent
            if ((match.p1 && !match.p2) || (!match.p1 && match.p2)) {
                matchHtml += `<div class="match-info">En attente du second joueur</div>`;
            }
            
            // Ajouter les champs de score si les deux joueurs sont présents
            if (bothPlayersPresent) {
                // Si le match est terminé, afficher les scores dans une boîte de score
                if (matchCompleted) {
                    if (match.score1 !== '' || match.score2 !== '') {
                        matchHtml += `
                        <div class="score-box">
                            <div class="score-box-value">
                                <span>${match.score1 || '0'}</span>
                                <span>-</span>
                                <span>${match.score2 || '0'}</span>
                            </div>
                        </div>`;
                    }
                } else {
                    // Sinon, afficher les champs de saisie de score
                    matchHtml += `
                    <div class="score-inputs">
                        <input type="number" min="0" class="score-input" id="score1-${i}-${j}" 
                            value="${match.score1}" placeholder="0" 
                            style="${match.score1 ? 'width: ' + Math.max(45, (match.score1.toString().length * 10) + 25) + 'px' : ''}"
                            onchange="updateScore(${i}, ${j}, 'score1', this.value)"
                            oninput="this.style.width = Math.max(45, (this.value.length * 10) + 25) + 'px'">
                        <span class="score-separator">-</span>
                        <input type="number" min="0" class="score-input" id="score2-${i}-${j}" 
                            value="${match.score2}" placeholder="0" 
                            style="${match.score2 ? 'width: ' + Math.max(45, (match.score2.toString().length * 10) + 25) + 'px' : ''}"
                            onchange="updateScore(${i}, ${j}, 'score2', this.value)"
                            oninput="this.style.width = Math.max(45, (this.value.length * 10) + 25) + 'px'">
                    </div>`;
                }
            }
            
            // Ajouter un bouton d'annulation si le match est terminé et que le tournoi n'est pas terminé
            if (matchCompleted && !tournamentCompleted) {
                matchHtml += `<button class="undo-match-btn" onclick="showUndoConfirmDialog(${i}, ${j})">
                    <span class="undo-icon">↺</span> Annuler ce match
                </button>`;
            }
            
            return matchHtml;
        }

        // Ajouter un joueur
        function addPlayer() {
            const nameInput = document.getElementById('playerName');
            const name = nameInput.value.trim();
            
            // Vérifier si le nom est vide
            if (!name) {
                showToast("Nom invalide", "Veuillez entrer un nom de machine valide.", "error");
                return;
            }
            
            // Vérifier si le joueur existe déjà (insensible à la casse)
            const playerExists = players.some(player => 
                player.name.toLowerCase() === name.toLowerCase()
            );
            
            if (playerExists) {
                showToast("Machine déjà inscrite", "Cette machine est déjà inscrite au tournoi !", "error");
                // Mettre en surbrillance le champ de saisie
                nameInput.focus();
                nameInput.classList.add('input-error');
                // Retirer la classe après un délai
                setTimeout(() => {
                    nameInput.classList.remove('input-error');
                }, 2000);
                return;
            }
            
            // Ajouter le joueur si la limite n'est pas atteinte
            if (players.length < 16) {
                // Vérifier si la machine est dans l'une des listes
                const isHacksawGaming = slotMachines.includes(name);
                const isNolimitCity = nolimitCityMachines.includes(name);
                
                // Déterminer la catégorie
                let category = "";
                if (isHacksawGaming) {
                    category = "Hacksaw Gaming";
                } else if (isNolimitCity) {
                    category = "Nolimit City";
                }
                
                // Ajouter le joueur avec sa catégorie
                players.push({
                    name: name,
                    category: category
                });
                nameInput.value = '';
                document.getElementById('count').innerText = `Slot ajoutés : ${players.length}/16`;
                updatePlayersDisplay();
                
                // Sauvegarder les données
                saveDataToLocalStorage();
                
                // Vérifier si on a atteint 16 joueurs
                if (players.length === 16) {
                    // Cacher le conteneur d'ajout de joueurs
                    document.getElementById('addPlayerContainer').style.display = 'none';
                    document.getElementById('randomSlotBtn').style.display = 'none';
                    // Afficher le bouton de tirage
                    document.getElementById('launchDraw').style.display = 'block';
                }
                
                showToast("Machine ajoutée", `${name} a été ajoutée au tournoi.`, "success");
            } else if (players.length >= 16) {
                showToast("Limite atteinte", "Le tournoi est limité à 16 machines !", "error");
            }
        }

        // Retirer un joueur
        function removePlayer(index) {
            // Ne pas permettre de retirer des joueurs une fois le tournoi commencé
            if (tournamentStarted) {
                showToast("Action impossible", "Impossible de retirer une machine une fois le tournoi commencé !", "error");
                return;
            }
            
            const playerName = players[index].name;
            players.splice(index, 1);
            document.getElementById('count').innerText = `Slot ajoutés : ${players.length}/16`;
            updatePlayersDisplay();
            
            // Sauvegarder les données
            saveDataToLocalStorage();
            
            // Si on avait 16 joueurs et qu'on en retire un, réafficher le conteneur d'ajout
            if (players.length < 16) {
                document.getElementById('addPlayerContainer').style.display = 'block';
                document.getElementById('randomSlotBtn').style.display = 'block';
                document.getElementById('launchDraw').style.display = 'none';
            }
            
            showToast("Machine retirée", `${playerName} a été retirée du tournoi.`, "success");
        }

        // Mettre à jour l'affichage des joueurs
        function updatePlayersDisplay() {
            const ul = document.getElementById('playersDisplay');
            ul.innerHTML = '';
            players.forEach((player, index) => {
                const li = document.createElement('li');
                li.id = `player-list-${player.name.replace(/\s+/g, '-')} `;
                
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                
                const playerInfo = document.createElement('div');
                playerInfo.style.display = 'flex';
                playerInfo.style.alignItems = 'center';
                
                const playerSpan = document.createElement('span');
                playerSpan.textContent = player.name;
                if (eliminated.includes(player.name)) {
                    playerSpan.classList.add('eliminated');
                }
                
                playerInfo.appendChild(playerSpan);
                
                // Ajouter le badge de catégorie seulement si la machine a une catégorie
                if (player.category) {
                    const categoryBadge = document.createElement('span');
                    categoryBadge.className = 'category-badge';
                    
                    // Ajouter une classe spécifique selon la catégorie
                    if (player.category === "Hacksaw Gaming") {
                        categoryBadge.classList.add('hacksaw');
                    } else if (player.category === "Nolimit City") {
                        categoryBadge.classList.add('nolimit');
                    }
                    
                    categoryBadge.textContent = player.category;
                    playerInfo.appendChild(categoryBadge);
                }
                
                const removeButton = document.createElement('button');
                removeButton.innerHTML = '<img src="./croix.png" alt="Supprimer" width="16" height="16">';
                removeButton.className = 'remove-btn';
                removeButton.title = 'Retirer cette machine';
                removeButton.onclick = function() { removePlayer(index); };
                
                // Désactiver le bouton de suppression si le tournoi a commencé
                if (tournamentStarted) {
                    removeButton.disabled = true;
                    removeButton.style.opacity = '0.5';
                    removeButton.style.cursor = 'not-allowed';
                }
                
                playerItem.appendChild(playerInfo);
                playerItem.appendChild(removeButton);
                
                li.appendChild(playerItem);
                ul.appendChild(li);
            });
        }

        // Mettre à jour l'affichage des gagnants précédents
        function updateWinnersDisplay() {
            const winnersList = document.getElementById('winnersList');
            winnersList.innerHTML = '';
            
            if (previousWinners.length > 0) {
                previousWinners.sort((a, b) => b.date - a.date); // Trier par date décroissante
                
                previousWinners.forEach(winner => {
                    const li = document.createElement('li');
                    li.className = 'winner-item';
                    
                    const trophy = document.createElement('div');
                    trophy.className = 'winner-trophy';
                    trophy.textContent = '🏆';
                    
                    const info = document.createElement('div');
                    info.className = 'winner-info';
                    
                    const name = document.createElement('div');
                    name.className = 'winner-name';
                    name.textContent = winner.name;
                    
                    const date = document.createElement('div');
                    date.className = 'winner-date';
                    date.textContent = winner.date.toLocaleDateString();
                    
                    info.appendChild(name);
                    info.appendChild(date);
                    
                    li.appendChild(trophy);
                    li.appendChild(info);
                    
                    winnersList.appendChild(li);
                });
            } else {
                const noWinners = document.createElement('li');
                noWinners.className = 'no-winners';
                noWinners.textContent = 'Aucun gagnant enregistré';
                winnersList.appendChild(noWinners);
            }
        }

        // Lancer le tirage
        function launchDraw() {
            tournamentStarted = true;
            shufflePlayers();
            placePlayersRandomly();
            document.getElementById('bracket').style.display = 'flex';
            document.getElementById('launchDraw').style.display = 'none';
            document.getElementById('resetButton').style.display = 'block';
            document.getElementById('randomSlotBtn').style.display = 'none';
            
            // Mettre à jour l'affichage pour désactiver les boutons de suppression
            updatePlayersDisplay();
            
            // Sauvegarder les données
            saveDataToLocalStorage();
            
            showToast("Tournoi lancé !", "Le tirage au sort a été effectué. Que la meilleure machine gagne !", "success");
        }

        // Mélanger les joueurs
        function shufflePlayers() {
            for (let i = players.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [players[i], players[j]] = [players[j], players[i]];
            }
        }

        // Placer les joueurs aléatoirement
        function placePlayersRandomly() {
            for (let i = 0; i < players.length; i++) {
                const matchIndex = Math.floor(i / 2);
                if (i % 2 === 0) {
                    matches[0][matchIndex].p1 = players[i].name;
                    matches[0][matchIndex].score1 = '';
                } else {
                    matches[0][matchIndex].p2 = players[i].name;
                    matches[0][matchIndex].score2 = '';
                }
            }
            renderBracket();
        }

        // Définir le gagnant d'un match
        function setWinner(roundIndex, matchIndex, winnerName) {
            // Vérifier si le tournoi est déjà terminé
            if (tournamentCompleted) {
                showToast("Action impossible", "Le tournoi est déjà terminé avec un gagnant déclaré !", "error");
                return;
            }
            
            const match = matches[roundIndex][matchIndex];
            
            // Vérifier si les deux joueurs sont présents
            if (!match.p1 || !match.p2) {
                showToast("Action impossible", "Impossible de déterminer un gagnant tant que les deux machines ne sont pas présentes !", "error");
                return;
            }
            
            // Nettoyer les noms des joueurs (enlever les checkmarks s'ils existent)
            const p1Name = match.p1.replace(' ✓', '');
            const p2Name = match.p2.replace(' ✓', '');
            
            // Déterminer le perdant
            let loserName = p1Name === winnerName ? p2Name : p1Name;
            
            // Ajouter le perdant à la liste des éliminés s'il n'y est pas déjà
            if (!eliminated.includes(loserName)) {
                eliminated.push(loserName);
                const playerElement = document.querySelector(`#player-list-${loserName.replace(/\s+/g, '-')} span`);
                if (playerElement) playerElement.classList.add('eliminated');
                
                // Ajouter à l'historique des éliminations
                const roundNames = ["Huitièmes", "Quarts", "Demi-finales", "Finale"];
                eliminationHistory.push({
                    winner: winnerName,
                    loser: loserName,
                    round: roundIndex,
                    roundName: roundNames[roundIndex],
                    time: new Date()
                });
                
                // Afficher le bouton d'historique des éliminations s'il n'est pas déjà visible
                document.getElementById('eliminationHistoryBtn').style.display = 'block';
                
                showToast(`${loserName} éliminée !`, `${winnerName} remporte le match et avance au prochain tour.`, "success");
            }

            // Marquer le match actuel comme terminé
            if (p1Name === winnerName) {
                matches[roundIndex][matchIndex].p1 = winnerName + ' ✓';
                matches[roundIndex][matchIndex].p2 = loserName;
            } else {
                matches[roundIndex][matchIndex].p2 = winnerName + ' ✓';
                matches[roundIndex][matchIndex].p1 = loserName;
            }
            
            // Conserver les scores existants (ne pas les réinitialiser)
            // Les scores sont maintenant purement informatifs
            
            const nextRound = roundIndex + 1;
            const nextMatchIndex = Math.floor(matchIndex / 2);
            
            // Faire avancer le gagnant au prochain tour
            if (nextRound < 4) {
                const nextMatch = matches[nextRound][nextMatchIndex];
                
                // Déterminer si le joueur doit être placé en position p1 ou p2
                // Si le match actuel a un index pair, le gagnant va en p1, sinon en p2
                if (matchIndex % 2 === 0) {
                    nextMatch.p1 = winnerName;
                    // Ne pas réinitialiser le score1, juste le définir s'il n'existe pas
                    if (nextMatch.score1 === undefined) nextMatch.score1 = '';
                } else {
                    nextMatch.p2 = winnerName;
                    // Ne pas réinitialiser le score2, juste le définir s'il n'existe pas
                    if (nextMatch.score2 === undefined) nextMatch.score2 = '';
                }
                
                renderBracket();
            } else {
                // C'est la finale, nous avons un gagnant du tournoi
                winner = winnerName;
                tournamentCompleted = true; // Marquer le tournoi comme terminé
                showVictoryMessage(winnerName);
            }
            
            // Sauvegarder les données
            saveDataToLocalStorage();
        }

        // Afficher le message de victoire
        function showVictoryMessage(winnerName) {
            document.getElementById('winnerText').innerHTML = `🏆 Félicitations <strong>${winnerName}</strong>, grande gagnante du tournoi ! 🎉`;
            document.getElementById('victoryMessage').style.display = 'block';
            document.getElementById('overlay').style.display = 'block';
        }

        // Fermer le message de victoire
        function closeVictoryMessage() {
            // Ajouter le gagnant à la liste des gagnants précédents
            if (winner) {
                previousWinners.push({
                    name: winner,
                    date: new Date()
                });
                
                // Mettre à jour l'affichage des gagnants
                updateWinnersDisplay();
                
                // Afficher un message indiquant que le tournoi est terminé
                if (tournamentCompleted) {
                    showToast("Tournoi terminé", `${winner} est la grande gagnante ! Pour commencer un nouveau tournoi, utilisez le bouton "Réinitialiser le tournoi".`, "success");
                }
                
                // Sauvegarder les données
                saveDataToLocalStorage();
            }
            
            document.getElementById('victoryMessage').style.display = 'none';
            document.getElementById('overlay').style.display = 'none';
        }

        // Afficher/masquer le panneau des gagnants précédents
        function toggleWinnersPanel() {
            const panel = document.getElementById('winnersPanel');
            const isVisible = panel.style.display === 'block';
            
            if (isVisible) {
                panel.style.display = 'none';
                document.getElementById('overlay').style.display = 'none';
            } else {
                updateWinnersDisplay(); // Mettre à jour la liste avant d'afficher
                panel.style.display = 'block';
                document.getElementById('overlay').style.display = 'block';
            }
        }

        // Afficher la boîte de dialogue de réinitialisation
        function showResetConfirmDialog() {
            document.getElementById('resetDialog').style.display = 'block';
            document.getElementById('overlay').style.display = 'block';
        }

        // Fermer la boîte de dialogue de réinitialisation
        function closeResetDialog() {
            document.getElementById('resetDialog').style.display = 'none';
            document.getElementById('overlay').style.display = 'none';
        }

        // Réinitialiser le tournoi avec option
        function resetTournamentWithOption(keepPlayers) {
            // Sauvegarder la liste des joueurs si demandé
            const savedPlayers = keepPlayers ? [...players] : [];
            
            // Réinitialiser les variables
            players = keepPlayers ? savedPlayers : [];
            matches = [];
            eliminated = [];
            winner = "";
            tournamentStarted = false;
            tournamentCompleted = false; // Réinitialiser l'état de complétion du tournoi
            
            // Réinitialiser l'interface
            document.getElementById('bracket').style.display = 'none';
            document.getElementById('resetButton').style.display = 'none';
            document.getElementById('launchDraw').style.display = keepPlayers && players.length === 16 ? 'block' : 'none';
            document.getElementById('eliminationHistoryBtn').style.display = eliminationHistory.length > 0 ? 'block' : 'none';
            document.getElementById('count').innerText = `Slot ajoutés : ${players.length}/16`;
            
            // Mettre à jour l'affichage des joueurs
            updatePlayersDisplay();
            
            // Réafficher le conteneur d'ajout de joueurs si nécessaire
            document.getElementById('addPlayerContainer').style.display = keepPlayers && players.length === 16 ? 'none' : 'block';
            document.getElementById('randomSlotBtn').style.display = keepPlayers && players.length === 16 ? 'none' : 'block';
            
            // Initialiser un nouveau bracket
            initBracket();
            
            // Sauvegarder les données
            saveDataToLocalStorage();
            
            showToast("Tournoi réinitialisé", keepPlayers ? "Le tournoi a été réinitialisé en conservant la liste des machines." : "Toutes les données du tournoi ont été effacées.", "success");
            
            // Fermer la boîte de dialogue
            closeResetDialog();
        }

        // Effacer toutes les données
        function clearAllData() {
            localStorage.removeItem('tournamentData');
            location.reload(); // Recharger la page pour repartir de zéro
        }

        // Afficher une notification toast
        function showToast(title, message, type = "default") {
            const toastContainer = document.getElementById('toastContainer');
            
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const toastTitle = document.createElement('div');
            toastTitle.className = 'toast-title';
            toastTitle.textContent = title;
            
            const toastMessage = document.createElement('div');
            toastMessage.className = 'toast-message';
            toastMessage.textContent = message;
            
            toast.appendChild(toastTitle);
            toast.appendChild(toastMessage);
            
            toastContainer.appendChild(toast);
            
            // Supprimer le toast après 3 secondes
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease-out forwards';
                setTimeout(() => {
                    toastContainer.removeChild(toast);
                }, 300);
            }, 3000);
        }
        
        // Afficher la boîte de dialogue de confirmation
        function showConfirmDialog(title, message, confirmCallback) {
            const dialog = document.getElementById('confirmDialog');
            const titleElement = document.getElementById('confirmDialogTitle');
            const messageElement = document.getElementById('confirmDialogMessage');
            const confirmButton = document.getElementById('confirmDialogConfirmBtn');
            
            titleElement.textContent = title;
            messageElement.textContent = message;
            
            // Définir la fonction de rappel pour le bouton de confirmation
            confirmButton.onclick = confirmCallback;
            
            // Afficher l'overlay et la boîte de dialogue
            document.getElementById('overlay').style.display = 'block';
            dialog.style.display = 'block';
        }
        
        // Fermer la boîte de dialogue de confirmation
        function closeConfirmDialog() {
            document.getElementById('confirmDialog').style.display = 'none';
            document.getElementById('overlay').style.display = 'none';
        }
        
        // Afficher l'historique des éliminations
        function showEliminationHistory() {
            const eliminationList = document.getElementById('eliminationList');
            eliminationList.innerHTML = '';
            
            if (eliminationHistory.length > 0) {
                eliminationHistory.forEach((elimination, index) => {
                    const li = document.createElement('li');
                    li.className = 'elimination-item';
                    
                    const header = document.createElement('div');
                    header.className = 'elimination-header';
                    
                    const eliminatedPlayer = document.createElement('span');
                    eliminatedPlayer.className = 'eliminated-player';
                    eliminatedPlayer.textContent = elimination.loser;
                    
                    const round = document.createElement('span');
                    round.className = 'elimination-round';
                    round.textContent = elimination.roundName;
                    
                    header.appendChild(eliminatedPlayer);
                    header.appendChild(round);
                    
                    const details = document.createElement('div');
                    details.className = 'elimination-details';
                    details.textContent = `Éliminée par ${elimination.winner}`;
                    
                    const time = document.createElement('div');
                    time.className = 'elimination-time';
                    time.textContent = elimination.time.toLocaleString();
                    
                    li.appendChild(header);
                    li.appendChild(details);
                    li.appendChild(time);
                    
                    eliminationList.appendChild(li);
                });
            } else {
                const emptyMessage = document.createElement('p');
                emptyMessage.textContent = 'Aucune élimination enregistrée';
                emptyMessage.style.textAlign = 'center';
                emptyMessage.style.color = 'var(--muted-text)';
                eliminationList.appendChild(emptyMessage);
            }
            
            document.getElementById('eliminationHistoryModal').style.display = 'block';
        }
        
        // Fermer l'historique des éliminations
        function closeEliminationHistory() {
            document.getElementById('eliminationHistoryModal').style.display = 'none';
        }

        // Gérer l'appui sur Entrée dans le champ de saisie
        document.getElementById('playerName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addPlayer();
            }
        });

        // Gérer le clic sur l'overlay pour fermer le message de victoire
        document.getElementById('overlay').addEventListener('click', function(e) {
            // Fermer uniquement si on clique directement sur l'overlay
            if (e.target === document.getElementById('overlay')) {
                closeVictoryMessage();
                closeConfirmDialog();
                closeResetDialog();
                closeEliminationHistory();
                toggleWinnersPanel();
                closeUndoConfirmDialog();
                closeRandomSlotDialog();
            }
        });

        // Ajouter l'événement de clic pour le bouton de thème
        document.getElementById('themeToggle').addEventListener('click', toggleTheme);

        // Initialiser le thème et le bracket au chargement
        document.addEventListener('DOMContentLoaded', function() {
            initTheme();
            initBracket();
            loadDataFromLocalStorage();
            updateWinnersDisplay();
        });

        // Initialiser le thème immédiatement pour éviter un flash de thème incorrect
        initTheme();
        // Initialiser le bracket au chargement
        initBracket();

        // Fermer la boîte de dialogue d'annulation de match
        function closeUndoConfirmDialog() {
            document.getElementById('undoConfirmDialog').style.display = 'none';
            document.getElementById('overlay').style.display = 'none';
        }

        // Mettre à jour le score d'un match
        function updateScore(roundIndex, matchIndex, scoreType, scoreValue) {
            matches[roundIndex][matchIndex][scoreType] = scoreValue;
            
            // Conserver la largeur du champ après la mise à jour
            const inputElement = document.getElementById(`${scoreType}-${roundIndex}-${matchIndex}`);
            if (inputElement && scoreValue) {
                inputElement.style.width = Math.max(45, (scoreValue.toString().length * 10) + 25) + 'px';
            }
            
            saveDataToLocalStorage();
            renderBracket();
        }

        // Afficher la boîte de dialogue de confirmation d'annulation de match
        function showUndoConfirmDialog(roundIndex, matchIndex) {
            const match = matches[roundIndex][matchIndex];
            
            // Obtenir les noms des joueurs sans les checkmarks
            const p1Name = match.p1.replace(' ✓', '');
            const p2Name = match.p2.replace(' ✓', '');
            
            // Déterminer le gagnant et le perdant
            const winnerName = match.p1.includes(' ✓') ? p1Name : p2Name;
            const loserName = match.p1.includes(' ✓') ? p2Name : p1Name;
            
            // Définir le message de confirmation
            document.getElementById('undoConfirmMessage').innerHTML = 
                `Êtes-vous sûr de vouloir annuler le résultat de ce match entre <strong>${p1Name}</strong> et <strong>${p2Name}</strong> ?<br><br>` +
                `<strong>${winnerName}</strong> ne sera plus considéré comme le vainqueur et <strong>${loserName}</strong> sera retiré de la liste des éliminés.`;
            
            // Configurer le bouton de confirmation pour appeler undoMatch avec les bons paramètres
            document.getElementById('undoConfirmBtn').onclick = function() {
                undoMatch(roundIndex, matchIndex);
                closeUndoConfirmDialog();
            };
            
            // Afficher la boîte de dialogue
            document.getElementById('undoConfirmDialog').style.display = 'block';
            document.getElementById('overlay').style.display = 'block';
        }

        // Fonction pour annuler un match
        function undoMatch(roundIndex, matchIndex) {
            const match = matches[roundIndex][matchIndex];
            
            // Obtenir les noms des joueurs sans les checkmarks
            const p1Name = match.p1.replace(' ✓', '');
            const p2Name = match.p2.replace(' ✓', '');
            
            // Déterminer le gagnant et le perdant
            const winnerName = match.p1.includes(' ✓') ? p1Name : p2Name;
            const loserName = match.p1.includes(' ✓') ? p2Name : p1Name;
            
            // Retirer le checkmark du gagnant
            match.p1 = p1Name;
            match.p2 = p2Name;
            
            // Retirer le perdant de la liste des éliminés
            const eliminatedIndex = eliminated.indexOf(loserName);
            if (eliminatedIndex !== -1) {
                eliminated.splice(eliminatedIndex, 1);
            }
            
            // Retirer de l'historique des éliminations
            eliminationHistory = eliminationHistory.filter(item => 
                !(item.winner === winnerName && item.loser === loserName && item.round === roundIndex)
            );
            
            // Mettre à jour l'affichage des joueurs pour retirer la classe eliminated
            const playerElement = document.querySelector(`#player-list-${loserName.replace(/\s+/g, '-')} span`);
            if (playerElement) playerElement.classList.remove('eliminated');
            
            // Vérifier si nous devons retirer le joueur des tours suivants
            if (roundIndex < 3) { // Pas la finale
                const nextRound = roundIndex + 1;
                const nextMatchIndex = Math.floor(matchIndex / 2);
                const nextMatch = matches[nextRound][nextMatchIndex];
                
                // Déterminer si le joueur était en position p1 ou p2 dans le match suivant
                if ((matchIndex % 2 === 0 && nextMatch.p1 === winnerName) || 
                    (matchIndex % 2 === 1 && nextMatch.p2 === winnerName)) {
                    
                    // Retirer le joueur du match suivant
                    if (matchIndex % 2 === 0) {
                        nextMatch.p1 = '';
                        nextMatch.score1 = '';
                    } else {
                        nextMatch.p2 = '';
                        nextMatch.score2 = '';
                    }
                    
                    // Si le match suivant a déjà un gagnant, annuler récursivement ce match aussi
                    if (nextMatch.p1.includes(' ✓') || nextMatch.p2.includes(' ✓')) {
                        undoMatch(nextRound, nextMatchIndex);
                    }
                }
            } else {
                // Si c'était la finale, réinitialiser le gagnant et le drapeau tournamentCompleted
                if (winner === winnerName) {
                    winner = "";
                    tournamentCompleted = false;
                }
            }
            
            // Mettre à jour l'affichage du bracket
            renderBracket();
            
            // Sauvegarder les données
            saveDataToLocalStorage();
            
            // Afficher un message de succès
            showToast("Match annulé", `Le résultat du match entre ${p1Name} et ${p2Name} a été annulé.`, "success");
        }
        
        // Sélectionner un type de slot
        function selectSlotType(element, type) {
            // Mettre à jour la variable globale
            selectedSlotType = type;
            
            // Mettre à jour l'interface utilisateur
            const options = document.querySelectorAll('.slot-type-option');
            options.forEach(option => {
                option.classList.remove('selected');
            });
            element.classList.add('selected');
        }
        
        // Afficher la boîte de dialogue de sélection aléatoire améliorée
        function showRandomSlotDialog() {
            // Réinitialiser l'état
            document.getElementById('randomSlotResult').style.display = 'none';
            document.getElementById('addRandomSlotBtn').style.display = 'none';
            document.getElementById('slotSelecting').style.display = 'none';
            document.getElementById('selectRandomBtn').disabled = false;
            
            // Sélectionner l'option "Toutes les machines" par défaut
            const allOption = document.querySelector('.slot-type-option[data-value="all"]');
            selectSlotType(allOption, 'all');
            
            // Afficher la boîte de dialogue
            document.getElementById('randomSlotDialog').style.display = 'block';
            document.getElementById('overlay').style.display = 'block';
        }
        
        // Fermer la boîte de dialogue de sélection aléatoire
        function closeRandomSlotDialog() {
            document.getElementById('randomSlotDialog').style.display = 'none';
            document.getElementById('overlay').style.display = 'none';
        }
        
        // Sélectionner une machine à sous aléatoire avec animation
        function selectRandomSlot() {
            // Désactiver le bouton pendant l'animation
            document.getElementById('selectRandomBtn').disabled = true;
            
            // Récupérer le type de machine sélectionné
            const slotType = selectedSlotType;
            
            let availableSlots = [];
            
            if (slotType === "all") {
                // Combiner les deux listes
                const allSlots = [...slotMachines, ...nolimitCityMachines];
                // Filtrer les machines qui ne sont pas déjà dans la liste des joueurs
                availableSlots = allSlots.filter(slot => 
                    !players.some(player => player.name === slot)
                );
            } else if (slotType === "hacksaw") {
                // Filtrer uniquement les machines Hacksaw Gaming
                availableSlots = slotMachines.filter(slot => 
                    !players.some(player => player.name === slot)
                );
            } else if (slotType === "nolimit") {
                // Filtrer uniquement les machines Nolimit City
                availableSlots = nolimitCityMachines.filter(slot => 
                    !players.some(player => player.name === slot)
                );
            }
            
            if (availableSlots.length === 0) {
                showToast("Aucune machine disponible", "Toutes les machines de cette catégorie sont déjà ajoutées au tournoi.", "error");
                document.getElementById('selectRandomBtn').disabled = false;
                return;
            }
            
            // Préparer la zone d'animation
            const slotSelecting = document.getElementById('slotSelecting');
            slotSelecting.innerHTML = '';
            slotSelecting.style.display = 'block';
            
            // Sélectionner une machine aléatoire
            const randomIndex = Math.floor(Math.random() * availableSlots.length);
            const finalSlot = availableSlots[randomIndex];
            
            // Déterminer la catégorie de la machine sélectionnée
            let category = "";
            if (slotMachines.includes(finalSlot)) {
                category = "Hacksaw Gaming";
            } else if (nolimitCityMachines.includes(finalSlot)) {
                category = "Nolimit City";
            }
            
            // Animer la sélection
            let count = 0;
            const maxCount = 15; // Nombre d'étapes d'animation
            const interval = setInterval(() => {
                // Sélectionner une machine aléatoire pour l'animation
                const animIndex = Math.floor(Math.random() * availableSlots.length);
                const animSlot = availableSlots[animIndex];
                
                // Créer un élément pour l'animation
                const slotItem = document.createElement('div');
                slotItem.className = 'slot-item';
                slotItem.textContent = count === maxCount - 1 ? finalSlot : animSlot;
                slotSelecting.appendChild(slotItem);
                
                // Supprimer les anciens éléments
                setTimeout(() => {
                    if (slotItem.parentNode === slotSelecting) {
                        slotSelecting.removeChild(slotItem);
                    }
                }, 200);
                
                count++;
                if (count >= maxCount) {
                    clearInterval(interval);
                    
                    // Cacher la zone d'animation
                    setTimeout(() => {
                        slotSelecting.style.display = 'none';
                        
                        // Afficher le résultat final
                        randomSlotSelected = finalSlot;
                        randomSlotCategory = category;
                        
                        document.getElementById('randomSlotName').textContent = finalSlot;
                        
                        const categoryElement = document.getElementById('randomSlotCategory');
                        if (category) {
                            categoryElement.textContent = category;
                            categoryElement.className = 'random-slot-category';
                            if (category === "Hacksaw Gaming") {
                                categoryElement.classList.add('hacksaw');
                            } else if (category === "Nolimit City") {
                                categoryElement.classList.add('nolimit');
                            }
                        } else {
                            categoryElement.textContent = '';
                        }
                        
                        document.getElementById('randomSlotResult').style.display = 'block';
                        document.getElementById('addRandomSlotBtn').style.display = 'inline-flex';
                        document.getElementById('selectRandomBtn').disabled = false;
                    }, 200);
                }
            }, 100);
        }
        
        // Ajouter la machine aléatoire sélectionnée
        function addRandomSlot() {
            if (!randomSlotSelected) {
                showToast("Erreur", "Aucune machine n'a été sélectionnée.", "error");
                return;
            }
            
            // Vérifier si la limite de joueurs est atteinte
            if (players.length >= 16) {
                showToast("Limite atteinte", "Le tournoi est limité à 16 machines !", "error");
                return;
            }
            
            // Ajouter la machine à la liste des joueurs avec sa catégorie
            players.push({
                name: randomSlotSelected,
                category: randomSlotCategory
            });
            document.getElementById('count').innerText = `Slot ajoutés : ${players.length}/16`;
            updatePlayersDisplay();
            
            // Sauvegarder les données
            saveDataToLocalStorage();
            
            // Vérifier si on a atteint 16 joueurs
            if (players.length === 16) {
                // Cacher le conteneur d'ajout de joueurs
                document.getElementById('addPlayerContainer').style.display = 'none';
                document.getElementById('randomSlotBtn').style.display = 'none';
                // Afficher le bouton de tirage
                document.getElementById('launchDraw').style.display = 'block';
            }
            
            // Fermer la boîte de dialogue
            closeRandomSlotDialog();
            
            // Afficher un message de succès
            showToast("Machine ajoutée", `${randomSlotSelected} a été ajoutée au tournoi.`, "success");
            
            // Réinitialiser la sélection
            randomSlotSelected = "";
            randomSlotCategory = "";
        }

// Fonction pour afficher les suggestions de machines
function showSuggestions(input) {
    const inputValue = input.value.trim().toLowerCase();
    const suggestionsContainer = document.getElementById('suggestionsList');
    
    // Vider le conteneur de suggestions
    suggestionsContainer.innerHTML = '';
    
    // Si l'entrée est vide, cacher les suggestions
    if (inputValue.length < 2) {
        suggestionsContainer.style.display = 'none';
        return;
    }
    
    // Rechercher des correspondances dans les deux listes
    const hacksawMatches = slotMachines.filter(machine => 
        machine.toLowerCase().includes(inputValue) && 
        !players.some(player => player.name === machine)
    );
    
    const nolimitMatches = nolimitCityMachines.filter(machine => 
        machine.toLowerCase().includes(inputValue) && 
        !players.some(player => player.name === machine)
    );
    
    // Combiner les résultats et limiter à 10 suggestions
    const allMatches = [...hacksawMatches, ...nolimitMatches].slice(0, 10);
    
    // Si aucune correspondance, afficher un message
    if (allMatches.length === 0) {
        const noSuggestions = document.createElement('div');
        noSuggestions.className = 'no-suggestions';
        noSuggestions.textContent = 'Aucune machine correspondante trouvée';
        suggestionsContainer.appendChild(noSuggestions);
    } else {
        // Créer un élément pour chaque suggestion
        allMatches.forEach(machine => {
            const item = document.createElement('div');
            item.className = 'suggestion-item';
            
            const nameSpan = document.createElement('span');
            nameSpan.className = 'suggestion-name';
            nameSpan.textContent = machine;
            
            const categorySpan = document.createElement('span');
            categorySpan.className = 'suggestion-category';
            
            if (slotMachines.includes(machine)) {
                categorySpan.textContent = 'Hacksaw';
                categorySpan.classList.add('hacksaw');
            } else if (nolimitCityMachines.includes(machine)) {
                categorySpan.textContent = 'Nolimit';
                categorySpan.classList.add('nolimit');
            }
            
            item.appendChild(nameSpan);
            item.appendChild(categorySpan);
            
            // Ajouter un événement de clic pour sélectionner cette suggestion
            item.addEventListener('click', function() {
                input.value = machine;
                suggestionsContainer.style.display = 'none';
                // Optionnel : ajouter automatiquement la machine après sélection
                // addPlayer();
            });
            
            suggestionsContainer.appendChild(item);
        });
    }
    
    // Afficher le conteneur de suggestions
    suggestionsContainer.style.display = 'block';
}

// Ajouter un événement d'entrée au champ de saisie
document.getElementById('playerName').addEventListener('input', function() {
    showSuggestions(this);
});

// Fermer les suggestions lorsqu'on clique ailleurs
document.addEventListener('click', function(e) {
    const suggestionsContainer = document.getElementById('suggestionsList');
    const playerNameInput = document.getElementById('playerName');
    
    if (e.target !== playerNameInput && e.target !== suggestionsContainer && !suggestionsContainer.contains(e.target)) {
        suggestionsContainer.style.display = 'none';
    }
});

// Fermer les suggestions avec la touche Échap
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        document.getElementById('suggestionsList').style.display = 'none';
    }
});
    </script>

    <!-- Mention légale -->
    <div class="legal-notice">
        Site créé avec IA.<br>Appartenant à Redwo.<br>Patouche Lamouche Inc.
    </div>
</body>
</html>

